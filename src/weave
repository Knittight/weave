#!/usr/bin/env python3
"""
Weave — Multi-runtime server manager for Knittight
"""

import argparse
import subprocess
import json
import os
import signal
from pathlib import Path

# ----------------------------
# Paths / state
# ----------------------------
WEAVE_DIR = Path.home() / ".weave"
SERVERS_FILE = WEAVE_DIR / "servers.json"
LOGS_DIR = WEAVE_DIR / "logs"

WEAVE_DIR.mkdir(exist_ok=True)
LOGS_DIR.mkdir(exist_ok=True)

if not SERVERS_FILE.exists():
    SERVERS_FILE.write_text("{}")

# ----------------------------
# Helpers
# ----------------------------
def load_servers():
    return json.loads(SERVERS_FILE.read_text())

def save_servers(servers):
    SERVERS_FILE.write_text(json.dumps(servers, indent=2))

def detect_runtime(file):
    if file.endswith(".py"):
        return "python3"
    if file.endswith(".js"):
        return "node"
    if file.endswith(".rb"):
        return "ruby"
    if file.endswith(".go"):
        return "go"
    raise ValueError(f"Cannot detect runtime for: {file}")

def build_command(runtime, file):
    if runtime == "go":
        return ["go", "run", file]
    return [runtime, file]

# ----------------------------
# Commands
# ----------------------------
def start_server(args):
    runtime = args.runtime or detect_runtime(args.file)
    name = args.name or f"{runtime}_{args.port}"

    cmd = build_command(runtime, args.file)

    if args.daemon:
        log_file = LOGS_DIR / f"{name}.log"
        with open(log_file, "w") as log:
            proc = subprocess.Popen(cmd, stdout=log, stderr=log)
    else:
        proc = subprocess.Popen(cmd)

    servers = load_servers()
    servers[name] = {
        "pid": proc.pid,
        "runtime": runtime,
        "port": args.port,
        "file": args.file,
    }
    save_servers(servers)

    print(f"Started {name} ({runtime}) on port {args.port} with PID {proc.pid}")

def stop_server(args):
    servers = load_servers()
    target = args.target

    for name, info in servers.items():
        if name == target or str(info["port"]) == target:
            try:
                os.kill(info["pid"], signal.SIGTERM)
                print(f"Stopped {name} (PID {info['pid']})")
            except ProcessLookupError:
                print(f"Process {info['pid']} not running")

            del servers[name]
            save_servers(servers)
            return

    print("Server not found.")

def status_servers(_args):
    servers = load_servers()
    if not servers:
        print("No servers running.")
        return

    print(f"{'NAME':<20}{'RUNTIME':<10}{'PORT':<6}{'PID':<8}")
    for name, info in servers.items():
        print(f"{name:<20}{info['runtime']:<10}{info['port']:<6}{info['pid']:<8}")

def list_runtimes(_args):
    print("Supported runtimes:")
    print("  python3  (.py)")
    print("  node     (.js)")
    print("  ruby     (.rb)")
    print("  go       (.go)")

def create_preset(args):
    path = Path(args.file)
    if path.exists():
        print(f"Error: {path} already exists.")
        return

    templates = {
        "python": """#!/usr/bin/env python3
from http.server import HTTPServer, SimpleHTTPRequestHandler
import sys

PORT = int(sys.argv[1]) if len(sys.argv) > 1 else 8000

with HTTPServer(('0.0.0.0', PORT), SimpleHTTPRequestHandler) as server:
    print(f"Serving on port {PORT}")
    server.serve_forever()
""",
        "node": """const express = require('express');
const app = express();
const PORT = process.argv[2] || 8000;

app.get('/', (req, res) => {
    res.send('Hello from Node.js server!');
});

app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});
""",
        "ruby": """require 'webrick'

port = ARGV[0] ? ARGV[0].to_i : 8000
server = WEBrick::HTTPServer.new(Port: port, DocumentRoot: Dir.pwd)

trap('INT') { server.shutdown }
puts "Server running on port #{port}"
server.start
""",
        "go": """package main

import (
    "fmt"
    "net/http"
    "os"
)

func main() {
    port := "8000"
    if len(os.Args) > 1 {
        port = os.Args[1]
    }
    fmt.Println("Server running on port", port)
    http.ListenAndServe(":" + port, http.FileServer(http.Dir(".")))
}
"""
    }

    path.write_text(templates[args.runtime])
    path.chmod(0o755)  # make executable
    print(f"{args.runtime} preset created at {path}")

# ----------------------------
# CLI
# ----------------------------
def main():
    parser = argparse.ArgumentParser(
        description="Weave — multi-runtime server manager"
    )
    sub = parser.add_subparsers(dest="command", required=True)

    # start
    start = sub.add_parser("start")
    start.add_argument("-r", "--runtime", help="Runtime (python3, node, ruby, go)")
    start.add_argument("-p", "--port", type=int, default=8000)
    start.add_argument("-F", "--file", required=True)
    start.add_argument("-n", "--name", help="Server name")
    start.add_argument("-d", "--daemon", action="store_true")
    start.set_defaults(func=start_server)

    # stop
    stop = sub.add_parser("stop")
    stop.add_argument("target", help="Server name or port")
    stop.set_defaults(func=stop_server)

    # status
    status = sub.add_parser("status")
    status.set_defaults(func=status_servers)

    # list
    lst = sub.add_parser("list")
    lst.set_defaults(func=list_runtimes)

    # pres (preset)
    pres = sub.add_parser("pres", help="Create a server preset for a runtime")
    pres.add_argument("-r", "--runtime", choices=["python", "node", "ruby", "go"], required=True, help="Runtime type")
    pres.add_argument("file", help="File to create")
    pres.set_defaults(func=create_preset)

    args = parser.parse_args()
    args.func(args)

if __name__ == "__main__":
    main()
